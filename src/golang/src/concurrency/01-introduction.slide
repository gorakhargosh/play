Concurrency
One piece at a time
Tags: go golang

Yesudeep Mangalapilly
Lead, Engineering - gTech AdSales (DevShop)
yesudeep@google.com
yesudeep@gmail.com


* Mmm... McGophers

.image images/gopher-go.jpg

.image images/mcdonalds-logo.svg


* Analysing a McDonald's Outlet

- Not OO; process-oriented.
- The design and analysis of a McDonald's restaurant.
- Replicating the restaurant.
- Pay attention to the flow of data, not so much to the flow of control.


* (1/2) Real world: People working independently of each other while communicating

- Waiting for a chat message to arrive as a blocking operation before you can respond.
- Postal mail using mailboxes as a non-blocking operation.
- Callbacks as a notification system when the post is delivered.

* (2/2) Real world: Communication is used to

- track progress
- schedule and prioritize tasks
- resolve conflicts
- resolve dependencies

* Key concepts

- Concurrency is [[https://www.youtube.com/watch?v=cN_DpYBzKso][not parallelism]].

- *Concurrency*, a way to compose structure of software to work in coordination.

- *Parallelism* is simultaneous execution of possibly related or unrelated things.

- Do not communicate by sharing memory; instead, share memory by communicating.

- Go gives you tools to shoot yourself in the foot, however.


* CSP (Communicating Sequential Processes)

- Based on paper by C A R Hoare (also inventor of quicksort, null reference).

- Schedule blocking operations to run in separate processes (*goroutines* in Go).

- Synchronizing between them by communicating over shared message queues
(*channels* in Go).

- Avoiding concurrency within each *sequential* process.


* Go Primitives: High-Level CSP (1/3)

- *Goroutines* (using `go` keyword)

  go func() {
     // Do something.
  }()

- *Channels* (message queues; blocking send; blocking receive) for lockstep communication

  a := <-ch     // Receive from a channel.
  ch <- 3       // Send to a channel.

- *Buffered* channels (non-blocking send until full; blocking receive)

  bch := make(chan bool, 2)  // Capacity 2.

- Receiving from a channel always blocks unless the channel is closed.

- Closing channels

  close(ch)


* Go Primitives: Locks, Semaphores, and Pools (2/3)

- Synchronized memory-sharing: [[https://godoc.org/sync#Mutex][sync.Mutex]]
- Distributing workload: [[https://godoc.org/sync#Pool][sync.Pool]]
- Waiting for multiple goroutines to complete: [[https://godoc.org/sync#WaitGroup][sync.WaitGroup]]
- Single-execution goroutines: [[https://godoc.org/sync#Once][sync.Once]]
- Condition variables: [[https://godoc.org/sync#Cond][sync.Cond]]

* Go Primitives: Atomic Operations (3/3)

- Atomic operations (increment, decrement, CAS, swaps, pointer dereferencing) [[https://godoc.org/sync/atomic][sync/atomic]]
- Why CAS (check-and-set)? Race conditions.
- See spinlock example later.
- Atomic counter example in semaphore counting.


* Pattern: Fan-in
* Pattern: Fan-out
* Pattern: PubSub

* Example: Non-blocking exit
* Example: Using `time.Sleep` to wait

* Example: Channels
* Example: Buffered channels
* Example: `nil` channels
* Example: Closing Channels
* Example: Reading from closed channels
* Example: Using signals for synchronized waiting

- Why this is flow-of-control, not flow-of-data.
- Resembles the goto statement advised against by Djikstra

* Example: Pipeline
* Example: WaitGroup


* Terminology

- I/O: blocking, non-blocking, asynchronous, synchronous
- Wait group
- Why single-threaded, event-driven, async I/O-based systems (e.g., nodejs) are fundamentally limited.


* Blocking I/O or computation

A very boring function written by Rob Pike.

.play a-01-boring-blocking-io-single-thread.go /show A OMIT/,/end show A OMIT/
