Namasté, Concurrency in Go!
One piecemeal at a time (sequentially).
Tags: go golang concurrency examples patterns


Yesudeep Mangalapilly | येसुदीप मंगलापिल्ली
_Lead_, _Engineering_ — DevShop (gTech AdSales)
yesudeep@google.com

# TODO(yesudeep): Telnet chat example http://synflood.at/tmp/golang-slides/mrmcd2012.html#1
# TODO(yesudeep):

* Why Go? Ask Flipkart.

.image images/ask-flipkart-about-go.png 550 _

* Why Go? Ask Apple.

.image images/ask-apple-about-go.png 550 _

* Why Go?

- Ask [[https://github.com/facebookgo/][github.com/facebookgo]]
- Ask Canonical (makes Ubuntu Linux), CloudFlare (CDN), Docker (Linux containers).
- Ask SoundCloud (social music platform), Twitter (social network)
- Ask Uber (cabs anybody?), Stack Exchange (hello stackoverflow.com? :)
- Ask GitHub, IBM, Dropbox, BBC Worldwide

- A long list of [[https://github.com/golang/go/wiki/GoUsers][users]].

* Pay attention. You're late to the party. No kidding.

* The free (hardware-accelerated) ride is over.

* Gratification

- Instant
- Delayed

* How does Google Search work?

* Google Search: A real demo

.image images/google-albert-einstein.png 700 _

* Faking Google search

.code example-google-search.go /^func fakeSearch/,/^}/

.code example-google-search.go /show fakeEngines OMIT/,/end show fakeEngines OMIT/

* Google Search: Sequential

.play example-google-search.go /^func Google1/,/^}/

* Google Search: Concurrent

.play example-google-search.go /^func Google2/,/^}/

* Google Search: Concurrent and Time-bound

.play example-google-search.go /^func Google3/,/^}/

* Google Search: Concurrent, Time-bound, and Replicated

.play example-google-search.go /^func Google4/,/^}/

* Google Search: Replication and first-come-first-served

.code example-google-search.go /^func First/,/^}/

* Real world

.image images/surgery.jpg 600 _

* Mmm... McGophers

.image images/gopher-go.jpg

.image images/mcdonalds-logo.svg

* Analysing a McDonald's Outlet

- Real world is NOT object-oriented; it is concurrent.
- The design and analysis of a McDonald's restaurant.
- Replicating the restaurant.
- Pay attention to the flow-of-data, then to the flow-of-control.

- TODO(yesudeep): Add a diagram here.

* Real world examples

- People working independently of each other while communicating.
- Should you block waiting for a chat message to arrive before you can respond?
- Postal mail - non-blocking sends.
- Async callbacks akin to SMS notification (when your Amazon order is out for delivery).

# Key points.

* Concurrency: Flow-of-data > flow-of-control

* Patterns: What you can do

- Pair - one-to-one communication
- Request-Response - stateless services to process requests
- Pipeline - aggregation from many sources and load balancing among many destinations
- Bus - one-to-many communication
- Pub-Sub - interest based one-to-many communication
- Survey - query multiple sources

* Patterns: Pair (one-to-one)

.image images/pattern-pair.png

* Patterns: Request-Response

- Client requests; server responds

.image images/pattern-reqrep.png

* Patterns: Pipeline (one-way data flow)

.image images/pattern-pipeline.png

* Patterns: Bus (many-to-many)

.image images/pattern-bus.png

* Patterns: PubSub (topic broadcasting)

.image images/pattern-pubsub.png

* Patterns: Survey (query a group)

.image images/pattern-survey.png

* Patterns: Adding behavior

- Message queues (buffered and unbuffered)
- Generators
- Multiplexing: fan-in, fan-out
- Replication (first-come-first-served)
- Signaling
- Throttling (rate-control) using semaphores
- Time-bounding
- Waiting
- Idling

* Concurrency: a way to compose structure of software to work in coordination

- Appreciably, a *concurrency*pattern* == _directed_acyclic_graph_ (DAG)
- Cycles indicate possible deadlocks, but do occur
- As acyclic as possible

.image images/deadlocked-trains.jpg 300 _

* Concurrency != parallelism

- More about *topology*; less about parallelism.
- Can work with a single processor core (scheduling by *timeslicing*); e.g. _beatboxing_
- *Facilitates*parallelism* if multiple processor cores are available
- Concurrency that scales over a network is called *distributed*computing*
- Video: [[https://www.youtube.com/watch?v=cN_DpYBzKso][Rob Pike explains why]]

* Parallelism: simultaneous execution of possibly related or unrelated things

- Best suitable for independently executing computation that needs no synchronization
- Examples: image processing

TODO(yesudeep): Pull examples from haskell concurrency talk.

* Go CSP (Communicating Sequential Processes)

- Based on [[http://www.usingcsp.com/cspbook.pdf][paper]] by [[https://en.wikipedia.org/wiki/Tony_Hoare][C. A. R. "Tony" Hoare]] (inventor of [[https://en.wikipedia.org/wiki/Quicksort][quick sort]] & null reference).

- Schedule blocking operations to run in separate processes (*goroutines* in Go).

- Synchronize by communicating over shared message queues (*channels* in Go).

- Avoiding concurrency within each *sequential* process.

- Do not communicate by sharing memory; instead, share memory by communicating.

* Go gives you tools to shoot yourself in the foot, however

- Shared state
- Mutexes
- Pools
- Atomic operations
- RW Mutexes
- Condition variables

* Terminology

* Terminology: Blocking or non-blocking

- Blocking operation (I/O or computation or idling)

    $ python -m SimpleHTTPServer
    Serving HTTP on 0.0.0.0 port 8000 ...
    ... takes over your command line ...
    [Interrupt with Ctrl-C to exit]

- Example idling:

    $ sleep 5
    ... 5 seconds pass ...
    $

- Non-blocking operation (I/O or computation)

    $ python -m SimpleHTTPServer &
    $ # You can type another command here...

* Terminology: Order in time

- Time goes left-to-right

- Synchronous (in order)

 |-----A----->||--------B-------->||-------C------->|

- Asynchronous (out-of-order)

 |----A----->|
    |-----B----------->|
                            |---C-->|

- Wait group (or barrier)

 |------------A------------->|
 |-------B-------->|         |
        |-------C------>|    |
                             |
 |----------waiting----------|----resume---->


* Terminology: Race conditions

- When someone quietly shifts your chair from underneath you right before you sit, you are about to experience a very loud *race* *condition*.
- Data race: When multiple goroutines access the same memory concurrently and at least one of them is a write.

* Terminology: Deadlock


* Concurrency Primitives

* Primitives: High-level operations

- Send
- Receive

* Primitives: High-Level CSP

- *Goroutines* are independently executing functions in the _same_address_space_.

  go func() {
     // Do something.
  }()

- *Channels* - _typed_message_queues_ (blocking send; blocking receive) for *lockstep* communication between goroutines (e.g. telephone)

  a := <-ch     // Receive from a channel.
  ch <- 3       // Send to a channel.

- *Buffered*channels* (non-blocking send until full; blocking receive; e.g. postal mail)

  bch := make(chan bool, 2)  // Capacity 2.

- Receiving from a channel always blocks unless the channel is closed.

  close(ch)
  <-ch  // non-blocking on closed channel.


* Primitives: Mutexes, wait groups and pools

- Synchronized memory access: [[https://godoc.org/sync#Mutex][sync.Mutex]]
- Distributing workload: [[https://godoc.org/sync#Pool][sync.Pool]]
- Waiting for multiple goroutines to complete (barriers): [[https://godoc.org/sync#WaitGroup][sync.WaitGroup]]
- Single-execution goroutines: [[https://godoc.org/sync#Once][sync.Once]]
- Condition variables: [[https://godoc.org/sync#Cond][sync.Cond]]

* Primitives: Atomic operations

- Implemented in hardware instruction set
- [[https://godoc.org/sync/atomic][sync/atomic]]: (add, CAS, swaps, stores, pointer dereferencing)
- Why CAS (compare-and-set)? To prevent data races

* Primitives: Example atomic operation (CAS)

- IA-64 bit assembly example:

.code compare-and-swap-uint64.s

* Waiting (infamous "Please wait...")

* Example: Blocking I/O, computation, or idling

A very boring function written by Rob Pike.

.play blocking-main.go /show A OMIT/,/end show A OMIT/

* Example: Non-blocking exit

- comes as a neat surprise

.play non-blocking-main.go /show A OMIT/,/end show A OMIT/

* Example: Using `os.Stdin` to wait

- avoid
- quirky
- unreliable
- human/stdin error-prone
- dependency on presence of a human being/standard input

.play waiting-using-stdin.go /show A OMIT/,/end show A OMIT/

* Example: Using `time.Sleep` to wait

- avoid
- unreliable
- what if the goroutine takes more time than we're waiting?
- what if the goroutine takes a lot less time than we're waiting?
- surely, there must be something better.

.play waiting-using-sleep.go /show A OMIT/,/end show A OMIT/

* Example: Using signal channels to wait

- Why this is flow-of-control, not flow-of-data: resembles the *goto* statement [[http://dl.acm.org/citation.cfm?id=362947&dl=ACM&coll=DL&CFID=698007377&CFTOKEN=71204148][advised against by Djikstra]].
- Prefer using [[https://godoc.org/sync#WaitGroup][wait groups]] for waiting, where possible, instead.
- Use this for signalling (upstream in pipelines, for example).

.play waiting-for-one-goroutine-using-signal-channel.go /show A OMIT/,/end show A OMIT/

* Example: Waiting for groups of goroutines

.play waiting-using-wait-groups.go /show A OMIT/,/end show A OMIT/

* Wait groups (or barriers)

- In message passing, any global communication (such as reduction or scatter) may imply a wait groups (or barriers).

- muliplexing aggregation and load balancing, for example.

* Channels: Talk to my handle

* Lockstep communication

.image images/talk-to-the-hand.jpg 600 _

* Example: Channels

.play channels.go

* Example: Channels have direction

* Generating channels

* Example: Generating channels

.play generator-pattern.go /show A OMIT/,/end show A OMIT/

* Example: Generators as services

.play generators-as-services.go /show A OMIT/,/end show A OMIT/

* Multiplexing

* Fanning-in

- e.g. tmux sharing a single TCP connection between multiple shell sessions

.image images/fan-in-gophers.jpg 300 _

* Example: Multiplexing (Fan-in)

.code generator-multiplexing-fan-in.go /^func fanIn/,/^}/

* Example: Multiplexing (Fan-in continued)

.play generator-multiplexing-fan-in.go /^func main/,/^}/

* Example: Multiplexing (Fan-in using select)

- Selecting communication.
- Pseudorandomly if multiple communications are ready.

.play generator-multiplexing-using-select.go /^func fanIn/,/^}/

* Example: Non-blocking select

- Selecting communication without waiting.

.play non-blocking-select.go /^func main/,/^}/

* Example: Multiplexing (Fan-out; load balancing)

- TODO(yesudeep): stackoverflow.

* Timeouts and moving on

* Example: Timing out a single communication

.play generator-timeout.go /^func main/,/^}/

* Example: Timing out entire conversations

.play generator-timeout-conversation.go /^func main/,/^}/

* Timing out: How it works


.play timeout-after.go /show A OMIT/,/end show A OMIT/

* Timing out: The emitter

.code timeout-after.go /^func gen/,/^}/


* Signalling

* Example: Using quit channels for signaling

.play quit-channels.go /show A OMIT/,/end show A OMIT/

* Example: Using quit channels and cleaning up

.play quit-channels-plus-cleanup.go /show A OMIT/,/end show A OMIT/

* Example: Buffered channels

.play buffered-channels.go /^func main/,/^}/

* Example: `nil` channels
* Example: Closing Channels
* Example: Reading from closed channels

* Race conditions (and shared state)

* Meme time

.image images/data-race-dragon.png _ 700

* Detecting race conditions

- tooling makes Go awesome:

  $ go (run|build|test...) -race foo.go

- not everything can be detected, but quite a bit can be.
- HUGE shout out to Dmitry Vyukov ([[https://twitter.com/dvyukov][@dvyukov]] and [[https://github.com/dvyukov][github.com/dvyukov]]) for making this possible.


* Example: Unsynchronized counter

.play race-condition-simple.go /^func main/,/^}/

* Example: Insidious goroutine closures

- closures share memory

.play race-condition-closure.go /^func raceClosure/,/^}/

* Example: Safe goroutine closures

- pass values as arguments

.play race-condition-closure.go /^func noRaceClosurePassArgument/,/^}/

* Example: Careful goroutine closures

- unique variable per iteration

.play race-condition-closure.go /^func noRaceClosureUniqueVariable/,/^}/

* Example: Careful with wait groups (barriers) too

- call `wg.Add(N)` *before* `go function()`

.play waiting-using-wait-groups.go /^func main/,/^}/

* Example: Careful with wait groups (barriers) too

- call `wg.Done()` before each goroutine returns (presumably using `defer`).

.play waiting-using-wait-groups.go /^func work/,/^}/

* Example: Loading Web service configuration non-racily

- when loading configuration for Web service into a map use a wait group to avoid a data race
- because goroutines can access map even before fully-loaded
- anywhere aggregation or scattering is involved along with non-synchronized shared memory, a wait group may be required to prevent data races
- use `init()` if possible; no goroutines can run before all `init()` functions executed.

* Mutexes (and shared state)

* Example: Synchronized shared state

.play mutex-atomic-int.go /^func main/,/^}/

* Example: Using mutexes to synchronize access

.code mutex-atomic-int.go /show A OMIT/,/end show A OMIT/


* Deadlocks

* Example: Ping Pong and Deadlock detection

.play ping-pong.go /show A OMIT/,/end show A OMIT/

- source: [[http://blog.golang.org/advanced-go-concurrency-patterns][Advanced Go Concurrency Patterns - Sameer Ajmani]]

* Starvation

* Pipelines

* What is a Pipeline?

- A *pipeline* is a series of stages connected by channels, where each stage is a group of goroutines running the same function.

- Goroutines *receive* values from _upstream_ via _inbound_ channels.
- Goroutines *perform*some*function* on that data, usually producing new values.
- Goroutines *send* values _downstream_ via _outbound_ channels.

.image images/pattern-pipeline.png

* Example: Draining pipelines [1/4]

- stage: consumer draining inbound channel

.play pipeline-no-cancellation.go /^func main/,/^}/

* Example: Draining pipelines [2/4]

- stage: emitters and outbound channels

.code pipeline-no-cancellation.go /^func gen/,/^}/

* Example: Draining pipelines [3/4]

- stage: squaring

.code pipeline-no-cancellation.go /^func sq/,/^}/

* Example: Draining pipelines [4/4]

- stage: multiplexing N inbound channels onto 1 outbound channel

.code pipeline-no-cancellation.go /^func merge/,/^}/

* ...but what if we only want some, not all?

* Example: Pipelines with cancellation [1/4]

- stage: consumer NOT draining inbound channel

.play pipeline-with-cancellation.go /^func main/,/^}/

* Example: Pipelines with cancellation [2/4]

- stage: emitters and outbound channels

.code pipeline-with-cancellation.go /^func gen/,/^}/

* Example: Pipelines with cancellation [3/4]

- stage: squaring

.code pipeline-with-cancellation.go /^func sq/,/^}/

* Example: Pipelines with cancellation [4/4]

- stage: multiplexing N inbound channels onto 1 outbound channel

.code pipeline-with-cancellation.go /^func merge/,/^}/

* Semaphores (and rate-control)

* Why?

.image images/single-lane-bridge.jpg

* Example: Semaphore Worker

.play semaphores-for-throttling-goroutines.go /^func worker/,/^}/

* Example: Throttling goroutines using buffered channels

.play semaphores-for-throttling-goroutines.go /^func main/,/^}/

* Example: Atomic counting to ensure semaphore works

- All or nothing.
- Check-and-set in hardware.

.play semaphores-for-throttling-goroutines.go /show atomicCounting OMIT/,/end show atomicCounting OMIT/


* Example: Spinlock and atomic operations
* Pattern: PubSub


* Hype 1: There is a "No" in "NodeJS"

- Single-threaded
- Event-driven
- Async I/O-based
- Callback hell
- New [[http://www.html5rocks.com/en/tutorials/es6/promises/][promises API]] helps a bit
- The "new" thing but fundamentally limited
- There is a lot more to concurrency than just this

* Links:

- [[http://www.golangpatterns.info/concurrency/futures][Go Patterns]]
