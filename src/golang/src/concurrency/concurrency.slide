Namasté, Concurrency!
One piecemeal at a time (sequentially).
Tags: go golang concurrency examples patterns


Yesudeep Mangalapilly | येसुदीप मंगलापिल्ली
_Lead_, _Engineering_ — gTech AdSales (DevShop)
yesudeep@google.com
yesudeep@gmail.com

# TODO(yesudeep): Telnet chat example http://synflood.at/tmp/golang-slides/mrmcd2012.html#1
# TODO(yesudeep):

* "I speak Spanish to God, German to my horse, and Go to connections that might make me wait."      — swdunlop on hackernews

* Gratification

- Instant
- Delayed

* How does Google Search work?

* Google Search: A real demo

.image images/google-albert-einstein.png 700 _

* Faking Google search

.code example-google-search.go /^func fakeSearch/,/^}/

.code example-google-search.go /show fakeEngines OMIT/,/end show fakeEngines OMIT/

* Google Search: Sequential

.play example-google-search.go /^func Google1/,/^}/

* Google Search: Concurrent

.play example-google-search.go /^func Google2/,/^}/

* Google Search: Concurrent and Time-bound

.play example-google-search.go /^func Google3/,/^}/

* Google Search: Concurrent, Time-bound, and Replicated

.play example-google-search.go /^func Google4/,/^}/

* Google Search: Replication and first-come-first-served

.code example-google-search.go /^func First/,/^}/

* Real world

.image images/surgery.jpg 600 _

* Mmm... McGophers

.image images/gopher-go.jpg

.image images/mcdonalds-logo.svg

* Analysing a McDonald's Outlet

- Not OO; process-oriented.
- The design and analysis of a McDonald's restaurant.
- Replicating the restaurant.
- Pay attention to the flow of data, not so much to the flow of control.

- TODO(yesudeep): Add a diagram here.

* Real world examples

- People working independently of each other while communicating.
- Should you block waiting for a chat message to arrive before you can respond?
- Postal mail using mailboxes as a non-blocking operation.
- Async callbacks akin to SMS notification (when your Amazon order is out for delivery).

# Key points.

* Concurrency: Flow-of-data > flow-of-control

* Patterns: What you can do

- Pair - one-to-one communication
- Request-Response - stateless services to process requests
- Pipeline - aggregation from many sources and load balancing among many destinations
- Bus - one-to-many communication
- Pub-Sub - interest based one-to-many communication

* Patterns: Pair (one-to-one)

.image images/pattern-pair.png

* Patterns: Request-Response

- Client requests; server responds

.image images/pattern-reqrep.png

* Patterns: Pipeline (one-way data flow)

.image images/pattern-pipeline.png

* Patterns: Bus (many-to-many)

.image images/pattern-bus.png

* Patterns: PubSub (topic broadcasting)

.image images/pattern-pubsub.png


* Patterns: How they are implemented

- Message queues (buffered and unbuffered)
- Generators
- Multiplexing: fan-in, fan-out
- Replication (first-come-first-served)
- Signaling
- Throttling (rate-control) using semaphores
- Time-bounding
- Waiting
- Idling

* Concurrency: a way to compose structure of software to work in coordination

- Appreciably, a *concurrency*pattern* == _directed_acyclic_graph_ (DAG)
- Cycles indicate possible deadlocks, but do occur

* Concurrency != parallelism

- Can work with a single processor core (scheduling by timeslicing)
- Facilitates parallelism if multiple processor cores are available
- Concurrency that scales over a network is called *distributed*computing*
- Video: [[https://www.youtube.com/watch?v=cN_DpYBzKso][Rob Pike explains why]]

* Parallelism: simultaneous execution of possibly related or unrelated things

- Best suitable for independently executing computation that needs no synchronization
- Examples: image processing

TODO(yesudeep): Pull examples from haskell concurrency talk.

* Go CSP (Communicating Sequential Processes)

- Based on [[http://www.usingcsp.com/cspbook.pdf][paper]] by [[https://en.wikipedia.org/wiki/Tony_Hoare][C. A. R. "Tony" Hoare]] (inventor of [[https://en.wikipedia.org/wiki/Quicksort][quick sort]] & null reference).

- Schedule blocking operations to run in separate processes (*goroutines* in Go).

- Synchronize by communicating over shared message queues (*channels* in Go).

- Avoiding concurrency within each *sequential* process.

- Do not communicate by sharing memory; instead, share memory by communicating.

* Go gives you tools to shoot yourself in the foot, however

- Shared state
- Mutexes
- Pools
- Atomic operations
- RW Mutexes
- Condition variables

* Terminology

* Terminology: Blocking or non-blocking

- Blocking operation (I/O or computation or idling)

    $ python -m SimpleHTTPServer
    Serving HTTP on 0.0.0.0 port 8000 ...
    ... takes over your command line ...
    [Interrupt with Ctrl-C to exit]

- Example idling:

    $ sleep 5
    ... 5 seconds pass ...
    $

- Non-blocking operation (I/O or computation)

    $ python -m SimpleHTTPServer &
    $ # You can type another command here...

* Terminology: Order in time

- Time goes left-to-right

- Synchronous (in order)

 |-----A----->||--------B-------->||-------C------->|

- Asynchronous (out-of-order)

 |----A----->|
    |-----B----------->|
                            |---C-->|

- Wait group

 |------------A------------->|
 |-------B-------->|         |
        |-------C------>|    |
                             |
 |----------waiting----------|----resume---->


* Terminology: Race conditions

- When someone quietly shifts your chair from underneath you right before you sit, you are about to experience a very loud *race* *condition*.
- Data race: When multiple goroutines access the same memory concurrently and at least one of them is a write.

* Terminology: Deadlock


* Concurrency Primitives

* Primitives: High-level operations

- Send
- Receive

* Primitives: High-Level CSP

- *Goroutines* are independently executing functions in the _same_address_space_.

  go func() {
     // Do something.
  }()

- *Channels* - typed _message_queues_ (blocking send; blocking receive) for *lockstep* communication between goroutines (e.g. telephone)

  a := <-ch     // Receive from a channel.
  ch <- 3       // Send to a channel.

- *Buffered* channels (non-blocking send until full; blocking receive; e.g. postal mail)

  bch := make(chan bool, 2)  // Capacity 2.

- Receiving from a channel always blocks unless the channel is closed.

  close(ch)
  <-ch  // non-blocking on closed channel.


* Primitives: Mutexes, wait groups and pools

- Synchronized memory access: [[https://godoc.org/sync#Mutex][sync.Mutex]]
- Distributing workload: [[https://godoc.org/sync#Pool][sync.Pool]]
- Waiting for multiple goroutines to complete: [[https://godoc.org/sync#WaitGroup][sync.WaitGroup]]
- Single-execution goroutines: [[https://godoc.org/sync#Once][sync.Once]]
- Condition variables: [[https://godoc.org/sync#Cond][sync.Cond]]

* Primitives: Atomic operations

- Implemented in hardware instruction set
- [[https://godoc.org/sync/atomic][sync/atomic]]: (add, CAS, swaps, stores, pointer dereferencing)
- Why CAS (compare-and-set)? To prevent data races

* Primitives: Example atomic operation (CAS)

- IA-64 bit assembly example:

.code compare-and-swap-uint64.s

* "Please wait..."

* Example: Blocking I/O or computation

A very boring function written by Rob Pike.

.play blocking-main.go /show A OMIT/,/end show A OMIT/

* Example: Non-blocking exit

- comes as a neat surprise

.play non-blocking-main.go /show A OMIT/,/end show A OMIT/

* Example: Using `os.Stdin` to wait

- avoid
- quirky
- unreliable
- human/stdin error-prone
- dependency on presence of a human being/standard input

.play waiting-using-stdin.go /show A OMIT/,/end show A OMIT/

* Example: Using `time.Sleep` to wait

- avoid
- unreliable
- what if the goroutine takes more time than we're waiting?
- what if the goroutine takes a lot less time than we're waiting?
- surely, there must be something better.

.play waiting-using-sleep.go /show A OMIT/,/end show A OMIT/

* Example: Using signal channels to wait

- Why this is flow-of-control, not flow-of-data: resembles the *goto* statement [[http://dl.acm.org/citation.cfm?id=362947&dl=ACM&coll=DL&CFID=698007377&CFTOKEN=71204148][advised against by Djikstra]].
- Prefer using [[https://godoc.org/sync#WaitGroup][wait groups]] for waiting, where possible, instead.
- Use this for signalling (upstream in pipelines, for example).

.play waiting-for-one-goroutine-using-signal-channel.go /show A OMIT/,/end show A OMIT/

* Example: Waiting for groups of goroutines

.play waiting-using-wait-groups.go /show A OMIT/,/end show A OMIT/

* Channels: Talk to my handle

.image images/talk-to-the-hand.jpg 600 _

* Example: Channels

.play channels.go

* Example: Channels have direction

* Generating channels

* Example: Generating channels

.play generator-pattern.go /show A OMIT/,/end show A OMIT/

* Example: Generators as services

.play generators-as-services.go /show A OMIT/,/end show A OMIT/

* Multiplexing

* Example: Multiplexing (Fan-in)

.code generator-multiplexing-fan-in.go /^func fanIn/,/^}/

* Example: Multiplexing (Fan-in continued)

.play generator-multiplexing-fan-in.go /^func main/,/^}/

* Example: Multiplexing (Fan-in using select)

- Selecting communication.
- Pseudorandomly if multiple communications are ready.

.play generator-multiplexing-using-select.go /^func fanIn/,/^}/

* Example: Non-blocking select

- Selecting communication without waiting.

.play non-blocking-select.go /^func main/,/^}/

* Timeouts and moving on

* Example: Timing out a single communication

.play generator-timeout.go /^func main/,/^}/

* Example: Timing out entire conversations

.play generator-timeout-conversation.go /^func main/,/^}/

* Signalling

* Example: Using quit channels for signaling

.play quit-channels.go /show A OMIT/,/end show A OMIT/

* Example: Using quit channels and cleaning up

.play quit-channels-plus-cleanup.go /show A OMIT/,/end show A OMIT/

* Example: Buffered channels

.play buffered-channels.go /^func main/,/^}/

* Example: `nil` channels
* Example: Closing Channels
* Example: Reading from closed channels

* Race conditions

.image images/data-race-dragon.png _ 700

* Example: Race condition

.play race-condition-simple.go /^func main/,/^}/

* Example: Detecting race conditions

  $ go (run|build|test...) -race foo.go

- not everything can be detected, but most of it can be.

* Deadlocks

* Example: Ping Pong and Deadlock detection

.play ping-pong.go /show A OMIT/,/end show A OMIT/

- source: [[http://blog.golang.org/advanced-go-concurrency-patterns][Advanced Go Concurrency Patterns - Sameer Ajmani]]


* Pipelines

* What is a Pipeline?

- series of stages connected by channels, where each stage is a group of goroutines running the same function.

- goroutines receive values from _upstream_ via _inbound_ channels.
- goroutines perform some function on that data, usually producing new values.
- goroutines send values _downstream_ via _outbound_ channels.

* Example: Unclean pipelines [1/4]

- stage: emitters and outbound channels

.code pipeline-no-cancellation.go /^func gen/,/^}/

* Example: Unclean pipelines [2/4]

- stage: squaring

.code pipeline-no-cancellation.go /^func sq/,/^}/

* Example: Unclean pipelines [2/4]

- stage: multiplexing N inbound channels onto 1 outbound channel

.code pipeline-no-cancellation.go /^func merge/,/^}/

* Example: Unclean pipelines [2/4]

- stage: consumer draining inbound channel

.play pipeline-no-cancellation.go /^func main/,/^}/

* But what if we don't want to read all the values...only some?


* Example: Semaphore - Worker

.play semaphores-for-throttling-goroutines.go /^func worker/,/^}/

* Example: Semaphore - Throttling goroutines

.play semaphores-for-throttling-goroutines.go /^func main/,/^}/

* Example: Semaphore - Atomic counting

- All or nothing.
- Check-and-set in hardware.

.play semaphores-for-throttling-goroutines.go /show atomicCounting OMIT/,/end show atomicCounting OMIT/


* Example: Spinlock and atomic operations
* Pattern: Fan-out
* Pattern: PubSub


* Hype 1: There is a "No" in "NodeJS"

- Single-threaded
- Event-driven
- Async I/O-based
- Callback hell
- New [[http://www.html5rocks.com/en/tutorials/es6/promises/][promises API]] helps a bit
- The "new" thing but fundamentally limited
- There is a lot more to concurrency than just this

* Links:

- [[http://www.golangpatterns.info/concurrency/futures][Go Patterns]]
